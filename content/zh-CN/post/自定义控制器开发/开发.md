# 云昊平台后端开发

云昊平台是基于 rancher 开发的容器云平台。使用 go 语言开发。云昊平台本质上可以理解为是一个第三方的 controller manager，其几乎全部功能的实现都是基于监听资源的变化触发的。也存在部分功能无法以 CRUD 的方式去体现(如测试通知器是否能正常使用)，这部分功能就会以 action 的方式扩展在对应资源中。

对于控制器的开发，rancher 并未直接使用 client-go 或者其他控制器框架，而是自己开发了一套叫做 Norman 框架。这个框架可以生成创建 crd 所需的代码，并且允许开发者监听资源的变化。在 2.5 中，rancher 引入了另一套自己开发的框架，wrangler。相比 norman，wrangler 的开发方式更加接近原生 client-go，可以预见半年一年内，这套框架都无法取代现有的 norman。在现阶段，开发还是会继续使用 norman，后续内容中也将以 norman 为主，介绍整个开发的流程。

## 一些前置文章

这儿都是一些官方的说明文档。里面包含了很多重要的知识点，我都会标注出来。

- rancher 开发概览: https://github.com/rancher/rancher/wiki/Rancher-2.x-Development-Overview 主要是 context。后续也会介绍
- norman api 介绍: https://github.com/rancher/api-spec/blob/master/specification.md 重点阅读 Schemas、Actions、Collections
- 添加 CRD 和 Controller 分类: https://github.com/rancher/rancher/wiki/Rancher-2.0---Adding-new-CRDs-and-custom-controllers
- rancher 开发最佳实践: https://github.com/rancher/rancher/wiki/Rancher-Development-Best-Practices

## 实际开发

### 新增 Actions 或 Links

前文中提到过，一种资源除了增删查改之外，可能还会有一些其他的行为。在这里就会通过 Actions 的方式去扩展。

扩展好后，在前端通过 api-ui 去查看对应资源时，就可以看到资源的实例上多出了对应的 action 内容。同时侧边栏也会多出 action 按钮以供调试。这里要注意，action 只能通过 post 请求触发，其他请求是没有 action 的处理的。

#### 实现 Action

以为 pod 添加 action 为例，首先我们在 ebcpaas 项目的`pkg\api\customization`目录下创建一个新的文件夹**pod**。随后在 pod 中创建一个 go 文件**pod_action.go**。

随后，我们可以在这个文件中实现一个 ActionHandler 方法，他表示这个类型在收到 Action 请求时需要如何处理。

```go
package pod
/*
方法名称无所谓，接收器是什么也无所谓，但是需要接受以下参数，并返回error

actionName string 本次action请求的名称，如upload
action types.Action 没看是干什么用的
apiContext types.APIContext 本次请求的上下文其中包含大量信息。比较常用的是这些参数
    ID string 目标资源的id
    Query url.Values 请求中的url参数
    AccessControl 发出请求的用户的权限控制器（能用于确认对特定资源拥有的权限）
    Request *http.Request 本次请求的req对象
    Response http.ResponseWriter 本次请求的ResponseWriter

    返回值，可以是任意报错，最好是httperror类型，这样能确保状态码符合语义。
*/
func PodActionHandler(actionName string, action *types.Action, apiContext *types.APIContext) error {
	switch actionName {
    case "foo":
        apiContext.Response.write([]byte("bar"))
		return nil
	}
	return httperror.NewAPIError(httperror.InvalidAction, "invalid action: "+actionName)
}
```

#### 注册 Action

在实现了 ActionHandler 后，我们需要将 ActionHandler 赋予相应的 Schema。在这个例子中，pod 是一个原生资源，同时属于 User(Rancher 中将用户集群的资源称为 User)类型，所以需要在`pkg/api/server/userstored/setup.go`下添加以下内容。

```go
import 	podaction "github.com/rancher/rancher/pkg/api/customization/pod" // 引入先前创建的pod ActionHanlder

// pod 方法用来为pod的schema进行定制，这个方法是我们自己加的
func Pod(schemas *types.Schemas) {
    schema := schemas.Schema(&schema.Version, client.PodType) // 从types中定义的全部schema中找到pod的schema
	schema.ActionHandler = podaction.PodActionHandler
}
...
// 这个方法中定义各个资源的action，以及创建对应的CRD
func Setup(ctx context.Context, mgmt *config.ScaledContext, clusterManager *clustermanager.Manager, k8sProxy http.Handler) error {
    // 在return之前添加
    Pod(schemas)
}

```

#### 扩展原有 Resource 和 Schema

现在我们已经实现了一个简单的 action，但是想要使用这个 action，我们需要拼凑出一个完整的资源地址，同时在后面加上`?action=upload`才可以使用。但是就上传这个 action 来说，pod 至少要在 running 阶段，才可以正常的进行 upload。否则这个请求必然是失败的，完全不需要执行。

所以我们可以在 `pod_action.go`中定义一个方法

```go
func PodFormatter(apiContext *types.APIContext, resource *types.RawResource) {
    // 如果当前的pod能够执行这个action，就在响应中添加foo action连接
	if canFooPod(apiContext, resource) {
		resource.AddAction(apiContext, "foo")
	}
}
```

并在`setup.go` pod 方法中加入

```go
schema.Formatter = podaction.PodFormatter
```

这样，在前端得到具体的对象实例时，可以通过 actions 字段中是否包含目标 action 来判断是否展示功能入口。并减少在拼接 url 时可能发生的错误。

![image](/uploads/9e624b46fb270fca44f96af8f1ad39c0/image.png)

上图是在[rancher 开发概览](https://github.com/rancher/rancher/wiki/Rancher-2.x-Development-Overview)中对请求处理流程的介绍。其中的 Validator 阶段会验证当前请求的资源所对应的 schema 中是否定义了相应的 action。如果没有的话，这个 action 请求会被拦截，并返回 ActionNotAvailable 错误。同时在 api-ui 中也无法查看目标资源拥有哪些 action。

想要避免这些情况，需要在 Schema 中加入 Action 属性。如果目标资源是我们自己定义的资源，则需要在对应的 Schema 定义(types/apis 中对应 api 的 schema.go)中加入 types.Action。如下所示:

```go
MustImportAndCustomize(&Version, v3.AzureADConfig{}, func(schema *types.Schema) {
    schema.ResourceActions = map[string]types.Action{
        "foo": {}, // 在这个资源上可以用 foo action
    }
}).
```

如果目标资源是原生的，或者是 rancher 的，总之是我们不应该做太多干涉的资源。则需要在`setup.go`去修改 pod 方法。如下所示：

```go
schema.ResourceActions = map[string]types.Action{
    "foo":   {},// 在这个资源上可以用 foo action
}
```

注意，上面的代码会覆盖原有的 action，如果不想覆盖，可以向原来的 actions map 中添加新的 kv。

这样一来，一个最简单的 Action 就写好了。在通过 Post 请求访问一个 pod 的 foo action 时，会直接返回 200 bar 响应。

> 在[norman api 介绍](https://github.com/rancher/api-spec/blob/master/specification.md)中提到，每种资源都有对应的集合类型(Collections)。集合类型有时也需要实现 action，这个时候只需要将 schema.ResourceActions 改为 schema.CollectionActions。并为其实现对应的 CollectionFormatter 即可

#### 在 Action 中查询信息

在前面的内容中，一个最简单的 Action 已经实现好了。但是实际开发场景中很少会有这么简单的需求，下面会介绍如何让这个 action 同时返回集群的名称(管理资源) 以及对应 pod 的镜像名称(用户集群资源)。

想要获取这两个属性，就要能够获取用户集群和管理集群中的信息，通过[rancher 开发概览](https://github.com/rancher/rancher/wiki/Rancher-2.x-Development-Overview#contexts-in-rancher)可知，我们需要获取到对应的 ScaledContext 和 UserContext。然后就可以通过上下文中提供的 Client 接口查询对应的资源。

在这里回过头看一眼 setup.go 中的 setup 方法，会发现其中包含有 4 个参数。在这里，我们关注其中两个:

- mgmt \*config.ScaledContext
- clusterManager \*clustermanager.Manager

在这里 mgmt 就是所需的 ScaledContext，而 userContext 则可以通过 clusterManager 的`UserContext(clusterID string)`方法得到。

具体实现如下：

```go
//假设接收器中已经得到了mgmt和clusterManager
func (h *Handler) getData(apiContext *types.APIContext) (clusterName, image string){
    // 通过上下文获取ClusterID并使用mgmt查询对应的名称
    clusterID := h.ClusterManager.ClusterName(apiContext)
    cluster, _ := h.mgmt.Management.Clusters("").Get(clusterID)// 这里可以看出，使用方法和client go基本是一样的。这是因为norman也生成client需要的接口并提供了默认实现。
    clusterName = cluster.Spec.DisplayName


    // 通过apiContext得到pod资源命名空间名称和pod id
    parts := strings.Split(apiContext.ID, ":")
	ns := parts[0]
    id := parts[1]

    // 通过ClusterManager获取对应的userContext
    userContext, _ := h.ClusterManager.UserContext(clusterID)
    pod, _ := userContext.Core.Pods(ns).Get(id, metav1.GetOptions{})
    image = pod.Spec.Containers[0].Image

    return
}
```

### 新增 Controller
#### 控制器分类
#### 实现控制器
#### 注册控制器
### 新增聚合 Schema 